// Copyright(C) 2024 Myrtle Software Ltd. All rights reserved.

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Functions in vollo-rt that can return an error return `error_t`.
 * NULL is returned where there are no errors, otherwise it is a null-terminated string containing
 * an error message.
 *
 * Error messages are owned by vollo-rt and can be freed with `vollo_rt_destroy_err`
 */
typedef const char* error_t;

/**
 * A context for performing computation on a vollo. You can construct a context with `vollo_rt_init`
 * and destroy it with `vollo_rt_destroy`.
 */
typedef void* vollo_rt_context_t;

/**
 * A handle to a model on the accelerator that can be used to perform computations.
 * You can construct a model with `vollo_rt_model_init` and destroy it with
 * `vollo_rt_model_destroy`.
 */
typedef const void* vollo_rt_model_t;

/**
 * bfloat16: Brain Floating Point Format
 * https://en.wikipedia.org/wiki/Bfloat16_floating-point_format
 *
 * Note: Make sure to NOT use C literals to create values of this type,
 * instead you can convert from float (by truncating or rounding as appropriate)
 */
typedef uint16_t bf16;

/**
 * Return a static string of the vollo-rt version.
 */
const char* vollo_rt_version(void);

/**
 * All APIs return the error as a c string. To prevent leaking the memory you can destroy
 * it afterwards.
 */
void vollo_rt_destroy_err(error_t err);

/**
 * Initialise the vollo-rt context. This must be called before any other vollo-rt functions.
 *
 * Logging level can be configured by setting the environment variable `VOLLO_RT_LOG` to one of:
 * "error", "warn", "info", "debug", or "trace"
 */
error_t vollo_rt_init(vollo_rt_context_t* context_ptr);

/**
 * Destroy vollo-rt context, releasing its associated resources.
 */
void vollo_rt_destroy(vollo_rt_context_t vollo);

/**
 * Add an accelerator.
 * The accelerator is specified by its index. The index refers to an accelerator in the sorted list
 * of PCI addresses. This should be called after `vollo_rt_init` but before `vollo_rt_load_program`
 */
error_t vollo_rt_add_accelerator(vollo_rt_context_t vollo, size_t accelerator_index);

/**
 * Load a program onto the Vollo accelerators.
 * This should be called after `vollo_rt_add_accelerator`, and must be called
 * before `vollo_rt_init_model`.
 *
 * A Vollo program is generated by the Vollo compiler, it is typically named
 * "<program_name>.vollo".
 * The program is intended for a specific hw_config (number of accelerators,
 * cores and other HW configuration options), this function will return an
 * error if any accelerator configuration is incompatible with the program.
 * Once loaded, the program provides inference for several models concurently.
 *
 * Note: This should only be called once per `vollo_rt_context_t`, as such if
 * you need to change or reset a program, first `vollo_rt_destroy` the current
 * context, then start a new context with `vollo_rt_init`.
 */
error_t vollo_rt_load_program(vollo_rt_context_t vollo, const char* program_path);

/**
 * Inspect the number of models loaded onto the vollo.
 */
size_t vollo_rt_num_models(vollo_rt_context_t vollo);

/**
 * Initialise a model. This should be called after `vollo_rt_load_program` and
 * must be called before `vollo_rt_add_job_bf16` or `vollo_rt_add_job_fp32`.
 *
 * Model initialisation does not actually do anything on the Vollo accelerators,
 * all accelerator initialisations are done as part of `vollo_rt_load_program`.
 * The initialisation here is quite cheap and simply a way to prepare the model
 * metadata and provide a handle to start jobs for a given model.
 *
 * Note: This does mean that for stateful models, resetting the state cannot be
 * achieved simply by getting a new handle to the same model!
 *
 * model_index:
 *   Programs can contain multiple models, the model index is used to select a
 *   specific model
 */
error_t vollo_rt_model_init(
  vollo_rt_context_t vollo, size_t model_index, vollo_rt_model_t* model_ptr);

/**
 * Destroy a model made by `vollo_rt_model_init`, releasing its associated resources.
 */
void vollo_rt_model_destroy(vollo_rt_model_t model);

/**
 * Get the number of inputs of a model
 *
 * Each input has its own distinct shape
 */
size_t vollo_rt_model_num_inputs(vollo_rt_model_t model);

/**
 * Get the number of outputs of a model
 *
 * Each output has its own distinct shape
 */
size_t vollo_rt_model_num_outputs(vollo_rt_model_t model);

/**
 * Get the shape for input at a given index
 *
 * The return value is a 0 terminated array of dims containing the input shape
 * The value lives for as long as the model
 */
const size_t* vollo_rt_model_input_shape(vollo_rt_model_t model, size_t input_index);

/**
 * Get the shape for output at a given index
 *
 * The return value is a 0 terminated array of dims containing the output shape
 * The value lives for as long as the model
 */
const size_t* vollo_rt_model_output_shape(vollo_rt_model_t model, size_t output_index);

/**
 * Get the number of elements for input at a given index
 *
 * This is simply the product of the dimensions returned by `vollo_rt_model_input_shape`,
 * it is provided to make it easier to allocate the correct number of elements.
 */
size_t vollo_rt_model_input_num_elements(vollo_rt_model_t model, size_t input_index);

/**
 * Get the number of elements for output at a given index
 *
 * This is simply the product of the dimensions returned by `vollo_rt_model_output_shape`,
 * it is provided to make it easier to allocate the correct number of elements.
 */
size_t vollo_rt_model_output_num_elements(vollo_rt_model_t model, size_t output_index);

/**
 * In a streaming model, the streaming dimension is not part of the shape.
 *
 * * It returns -1 when there is no streaming dimension
 * * It otherwise returns the dim index
 *   For example, for a shape `(a, b, c)` and streaming dim index 1, the full shape is:
 *   `(a, streaming_dim, b, c)`
 */
int vollo_rt_model_input_streaming_dim(vollo_rt_model_t model, size_t input_index);

/**
 * In a streaming model, the streaming dimension is not part of the shape.
 *
 * * It returns -1 when there is no streaming dimension
 * * It otherwise returns the dim index
 *   For example, for a shape `(a, b, c)` and streaming dim index 1, the full shape is:
 *   `(a, streaming_dim, b, c)`
 */
int vollo_rt_model_output_streaming_dim(vollo_rt_model_t model, size_t output_index);

/**
 * Sets up a computation on the vollo accelerator where the inputs and outputs are in brain-float 16
 * format.
 *
 * Note: The computation is only started on the next call to vollo_poll. This way it is possible
 * to set up several computations that are kicked off at the same time.
 *
 * - vollo:
 *     the context that the computation should be run on
 * - model:
 *     the program to run
 * - user_ctx:
 *     a user context that will be returned on completion. This can be used to disambiguate when
 *     multiple models are running concurrently.
 *     NOTE: the jobs for a single model are guaranteed to come back in order, but the jobs for
 *     different models are not.
 * - input_data:
 *     a pointer to the start of an array with pointers to the start of the data to each input the
 *     number of inputs is given by `vollo_rt_model_num_inputs` each input length is the product of
 *     the shape given by `vollo_rt_model_input_shape`
 *     (or more convenient: `vollo_rt_model_input_num_elements`)
 *     lifetime:
 *       - The outer array only needs to live until `vollo_rt_add_job_bf16` returns
 *       - The input buffers need to live until `vollo_rt_poll` returns with the completion for
 *         this job
 * - output_data:
 *     a pointer to the start of an array with pointers to the start of the data to each output
 *     buffer the number of outputs is given by `vollo_rt_model_num_outputs` each output length is
 *     the product of the shape given by `vollo_rt_model_output_shape`
 *     (or more convenient: `vollo_rt_model_output_num_elements`)
 *     lifetime:
 *       - The outer array only needs to live until `vollo_rt_add_job_bf16` returns
 *       - The output buffers need to live until `vollo_rt_poll` returns with the completion for
 *         this job
 */
error_t vollo_rt_add_job_bf16(
  vollo_rt_context_t vollo,
  vollo_rt_model_t model,
  uint64_t user_ctx,
  const bf16* const* input_data,
  bf16* const* output_data);

/**
 * Sets up a computation on the vollo accelerator where the inputs and outputs are in fp32 format.
 *
 * Note:
 * - The computation will still be performed in bf16 but the driver will perform the conversion.
 * - The computation is only started on the next call to vollo_poll. This way it is possible
 *   to set up several computations that are kicked off at the same time.
 *
 * - vollo:
 *     the context that the computation should be run on
 * - model:
 *     the program to run
 * - user_ctx:
 *     a user context that will be returned on completion. This can be used to disambiguate when
 *     multiple models are running concurrently.
 *     NOTE: the jobs for a single model are guaranteed to come back in order, but the jobs for
 *     different models are not.
 * - input_data:
 *     a pointer to the start of an array with pointers to the start of the data to each input the
 *     number of inputs is given by `vollo_rt_model_num_inputs` each input length is the product of
 *     the shape given by `vollo_rt_model_input_shape`
 *     (or more convenient: `vollo_rt_model_input_num_elements`)
 *     lifetime:
 *       - The outer array only needs to live until `vollo_rt_add_job_fp32` returns
 *       - The input buffers need to live until `vollo_rt_poll` returns with the completion for
 *         this job
 * - output_data:
 *     a pointer to the start of an array with pointers to the start of the data to each output
 *     buffer the number of outputs is given by `vollo_rt_model_num_outputs` each output length is
 *     the product of the shape given by `vollo_rt_model_output_shape`
 *     (or more convenient: `vollo_rt_model_output_num_elements`)
 *     lifetime:
 *       - The outer array only needs to live until `vollo_rt_add_job_fp32` returns
 *       - The output buffers need to live until `vollo_rt_poll` returns with the completion for
 *         this job
 */
error_t vollo_rt_add_job_fp32(
  vollo_rt_context_t vollo,
  vollo_rt_model_t model,
  uint64_t user_ctx,
  const float* const* input_data,
  float* const* output_data);

/**
 * Poll the vollo accelerator for completion.
 *
 * Note: Polling also initiates transfers for new jobs, so you must poll before any progress
 * on these new jobs can be made.
 *
 *   num_completed: out: the number of completed user_ctx returned
 *   returned_user_ctx: buffer for the returned user_ctx of completed jobs, this will only be
 *                      valid until the next call to vollo_poll.
 */
error_t vollo_rt_poll(
  vollo_rt_context_t vollo, size_t* num_completed, const uint64_t** returned_user_ctx);
